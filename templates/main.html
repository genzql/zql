<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZQL Transpiler</title>
    <style>

        .editor {
            height: 400px;
        }

        [type="hidden"] {
            display: none;
        }

    </style>
</head>
<body>
    <h1>ZQL Transpiler</h1>
    <div id="editor" class="editor"></div>

    <form id="form" method="POST" action="/transpile">
        <textarea type="hidden" id="inputString" name="inputString">{{ query }}</textarea>
        <br/>
        <button type="submit">Transpile</button>
    </form>

    <h2>Transpilation Result</h2>
    <pre>{{ transpilation_result }}</pre>

    <h2>Client Response</h2>
    <div id="results"></div>

    {% if error_message %}
        <h2>Error Message</h2>
        <pre>{{ error_message }}</pre>
    {% endif %}

    <!-- Use Monaco Editor via CDN -->
    <!-- https://stackoverflow.com/a/63179814 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.26.1/min/vs/loader.min.js"></script>
    <script type="module">
        // The loader.min.js script provides these modules:
        // global require
        // global monaco

        require.config({
            paths: {
                "vs": "https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.26.1/min/vs"
            }
        })

        const zqlConfig = {
            ignoreCase: true,
            keywords: ["yass", "tfw", "say", "be", "sike", "fax", "uh"],
            tokenizer: {
                root: [
                    // Keywords
                    // Multi-Token Keywords
                    [/its giving/, "keyword"],
                    [/say less/, "keyword"],
                    [/no cap/, "delimiter"],
                    [/@?[a-zA-Z][\w$]*/, {
                        cases: {
                            "@keywords": "keyword",
                            "@default": "source",
                        },
                    }],
                    // Literal Values
                    [/".*?"/, "string"],
                    [/\d*\.\d+([eE][\-+]?\d+)?/, "number.float"],
                    [/\d+/, "number"],
                ],
            },
        }

        const editorEl = document.getElementById("editor")
        const formEl = document.getElementById("form")
        const inputStringEl = document.getElementById("inputString")
        const resultsEl = document.getElementById("results")

        require(["vs/editor/editor.main"], () => {

            // Configure custom ZQL syntax highlighting for code editor.
            monaco.languages.register({ id: "zql" })
            monaco.languages.setMonarchTokensProvider("zql", zqlConfig)

            // Jinja returns the original query escaped for rendering in HTML.
            // The template populates the escaped string in the hidden textarea,
            // which safely unescapes any HTML characters. Then, we read the
            // sanitized value from the textarea value, which we can now use in
            // JavaScript without risk of cross-site scripting vulnerabilities.
            const originalQuery = inputStringEl.value
            const editor = monaco.editor.create(editorEl, {
                value: originalQuery,
                language: "zql",
                theme: "vs-dark",
            })

            // The Monaco editor only works on div elements, not textarea. So, 
            // to submit the code to the backend, we copy the editor input to
            // the hidden textarea before submitting the form.
            formEl.addEventListener("submit", (e) => {
                const content = editor.getValue()
                if (!content) e.preventDefault()
                inputStringEl.value = content
            })

        })

        // Import and initialize Preact and htm
        import { h, render } from 'https://esm.sh/preact'
        import htm from 'https://esm.sh/htm'

        const html = htm.bind(h)

        function ResultRow({ columns, row }) {
            const cells = columns.map((name) => (
                html`<td>${row?.[name]}</td>`
            ))
            return html`<tr>${cells}</tr>`
        }

        function ResultTable({ columns, rows }) {
            const noResultsMessage = html`<p>Query returned no results.</p>`
            const headers = columns.map((name) => (
                html`<th>${name}</th>`
            ))
            const tableRows = rows.map((row) => (
                html`<${ResultRow} columns=${columns} row=${row} />`
            ))

            return html`
                <table>
                    <tr>${headers}</tr>
                    ${tableRows}
                </table>
                ${rows.length === 0 && noResultsMessage}
            `
        }

        const queryColumns = {{ response_columns|tojson }}
        const queryRows = {{ client_response|tojson }}
        const resultTable = html`
            <${ResultTable} columns=${queryColumns} rows=${queryRows} />
        `
        render(resultTable, resultsEl)

    </script>
</body>
</html>
